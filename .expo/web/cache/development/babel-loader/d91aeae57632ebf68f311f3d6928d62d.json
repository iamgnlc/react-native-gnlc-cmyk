{"ast":null,"code":"var _jsxFileName = \"/Users/gnlc/Code/react-native-gnlc-cmyk/node_modules/expo-linear-gradient/build/LinearGradient.js\";\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport ColorPropType from \"react-native-web/dist/exports/ColorPropType\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport ViewPropTypes from \"react-native-web/dist/exports/ViewPropTypes\";\nimport processColor from \"react-native-web/dist/exports/processColor\";\nimport NativeLinearGradient from \"./NativeLinearGradient\";\nexport default class LinearGradient extends React.Component {\n  render() {\n    let _this$props = this.props,\n        {\n      colors,\n      locations,\n      start,\n      end\n    } = _this$props,\n        props = _objectWithoutProperties(_this$props, [\"colors\", \"locations\", \"start\", \"end\"]);\n\n    if (locations && colors.length !== locations.length) {\n      console.warn('LinearGradient colors and locations props should be arrays of the same length');\n      locations = locations.slice(0, colors.length);\n    }\n\n    return React.createElement(NativeLinearGradient, _extends({}, props, {\n      colors: Platform.select({\n        web: colors,\n        default: colors.map(processColor)\n      }),\n      locations: locations,\n      startPoint: _normalizePoint(start),\n      endPoint: _normalizePoint(end),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 12\n      }\n    }));\n  }\n\n}\nLinearGradient.propTypes = _objectSpread({}, ViewPropTypes, {\n  colors: PropTypes.arrayOf(ColorPropType).isRequired,\n  locations: PropTypes.arrayOf(PropTypes.number),\n  start: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.object]),\n  end: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.object])\n});\n\nfunction _normalizePoint(point) {\n  if (!point) {\n    return undefined;\n  }\n\n  if (Array.isArray(point) && point.length !== 2) {\n    console.warn('start and end props for LinearGradient must be of the format [x,y] or {x, y}');\n    return undefined;\n  }\n\n  return Array.isArray(point) ? point : [point.x, point.y];\n}","map":{"version":3,"sources":["../src/LinearGradient.tsx"],"names":[],"mappings":";;;;;;;;;;;;AAAA,OAAO,SAAP,MAAsB,YAAtB;AACA,OAAO,KAAP,MAAkB,OAAlB;;;;;AAGA,OAAO,oBAAP;AAWA,eAAc,MAAO,cAAP,SAA8B,KAAK,CAAC,SAApC,CAAoD;AAShE,EAAA,MAAM,GAAA;AACJ,sBAAkD,KAAK,KAAvD;AAAA,QAAI;AAAE,MAAA,MAAF;AAAU,MAAA,SAAV;AAAqB,MAAA,KAArB;AAA4B,MAAA;AAA5B,KAAJ;AAAA,QAAwC,KAAxC;;AAEA,QAAI,SAAS,IAAI,MAAM,CAAC,MAAP,KAAkB,SAAS,CAAC,MAA7C,EAAqD;AACnD,MAAA,OAAO,CAAC,IAAR,CAAa,+EAAb;AACA,MAAA,SAAS,GAAG,SAAS,CAAC,KAAV,CAAgB,CAAhB,EAAmB,MAAM,CAAC,MAA1B,CAAZ;AACD;;AAED,WACE,oBAAC,oBAAD,eACM,KADN;AAEE,MAAA,MAAM,EAAE,QAAQ,CAAC,MAAT,CAAgB;AACtB,QAAA,GAAG,EAAE,MADiB;AAEtB,QAAA,OAAO,EAAE,MAAM,CAAC,GAAP,CAAW,YAAX;AAFa,OAAhB,CAFV;AAME,MAAA,SAAS,EAAE,SANb;AAOE,MAAA,UAAU,EAAE,eAAe,CAAC,KAAD,CAP7B;AAQE,MAAA,QAAQ,EAAE,eAAe,CAAC,GAAD,CAR3B;AAAA;AAAA;AAAA;AAAA;AAAA,OADF;AAYD;;AA7B+D;AACzD,cAAA,CAAA,SAAA,qBACF,aADE;AAEL,EAAA,MAAM,EAAE,SAAS,CAAC,OAAV,CAAkB,aAAlB,EAAiC,UAFpC;AAGL,EAAA,SAAS,EAAE,SAAS,CAAC,OAAV,CAAkB,SAAS,CAAC,MAA5B,CAHN;AAIL,EAAA,KAAK,EAAE,SAAS,CAAC,SAAV,CAAoB,CAAC,SAAS,CAAC,OAAV,CAAkB,SAAS,CAAC,MAA5B,CAAD,EAAsC,SAAS,CAAC,MAAhD,CAApB,CAJF;AAKL,EAAA,GAAG,EAAE,SAAS,CAAC,SAAV,CAAoB,CAAC,SAAS,CAAC,OAAV,CAAkB,SAAS,CAAC,MAA5B,CAAD,EAAsC,SAAS,CAAC,MAAhD,CAApB;AALA;;AA+BT,SAAS,eAAT,CAAyB,KAAzB,EAAwD;AACtD,MAAI,CAAC,KAAL,EAAY;AACV,WAAO,SAAP;AACD;;AAED,MAAI,KAAK,CAAC,OAAN,CAAc,KAAd,KAAwB,KAAK,CAAC,MAAN,KAAiB,CAA7C,EAAgD;AAC9C,IAAA,OAAO,CAAC,IAAR,CAAa,8EAAb;AACA,WAAO,SAAP;AACD;;AAED,SAAO,KAAK,CAAC,OAAN,CAAc,KAAd,IAAuB,KAAvB,GAA+B,CAAC,KAAK,CAAC,CAAP,EAAU,KAAK,CAAC,CAAhB,CAAtC;AACD","sourcesContent":["import PropTypes from 'prop-types';\nimport React from 'react';\nimport { ColorPropType, Platform, View, ViewPropTypes, processColor } from 'react-native';\n\nimport NativeLinearGradient from './NativeLinearGradient';\n\ntype Props = {\n  colors: string[];\n  locations?: number[] | null;\n  start?: Point | null;\n  end?: Point | null;\n} & React.ComponentProps<typeof View>;\n\ntype Point = { x: number; y: number } | [number, number];\n\nexport default class LinearGradient extends React.Component<Props> {\n  static propTypes = {\n    ...ViewPropTypes,\n    colors: PropTypes.arrayOf(ColorPropType).isRequired,\n    locations: PropTypes.arrayOf(PropTypes.number),\n    start: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.object]),\n    end: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.object]),\n  };\n\n  render() {\n    let { colors, locations, start, end, ...props } = this.props;\n\n    if (locations && colors.length !== locations.length) {\n      console.warn('LinearGradient colors and locations props should be arrays of the same length');\n      locations = locations.slice(0, colors.length);\n    }\n\n    return (\n      <NativeLinearGradient\n        {...props}\n        colors={Platform.select({\n          web: colors as any,\n          default: colors.map(processColor),\n        })}\n        locations={locations}\n        startPoint={_normalizePoint(start)}\n        endPoint={_normalizePoint(end)}\n      />\n    );\n  }\n}\n\nfunction _normalizePoint(point: Point | null | undefined): [number, number] | undefined {\n  if (!point) {\n    return undefined;\n  }\n\n  if (Array.isArray(point) && point.length !== 2) {\n    console.warn('start and end props for LinearGradient must be of the format [x,y] or {x, y}');\n    return undefined;\n  }\n\n  return Array.isArray(point) ? point : [point.x, point.y];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}